"""
 Title: Python final project
 Author: Omer Reznik
 Description: A WSGI web app for displaying 7-day weather forecast for a city
 Reviewed by: Ben, Aviad
"""
import os
import logging
import socket
# request: to access incoming request data that will be submitted via the HTML form
# url_for(): to generate URLs
# flash(): to flash a confirmation/error message when a request is processed
# redirect(): to redirect the client to a different location
from flask import Flask, render_template, request, flash
import wf_helper

# The first argument is the name of the applicationâ€™s module or package.
# __name__ is a convenient shortcut for this that is appropriate for most cases.
# so that Flask knows where to look for resources such as templates and static files.
# create a new application instance called app, passing the special __name__ variable,
# which is needed for Flask to set up some paths behind the scenes.
# An instance of this class will be our WSGI application
app = Flask(__name__)


# secret key for making flash messages
app.config['SECRET_KEY'] = os.urandom(24).hex()


# A decorator to create a view function called index()
# route parameter is the tuple ('GET', 'POST') to accept both GET and POST
# route() decorator tells Flask what URL should trigger our function
@app.route('/', methods=('GET', 'POST'))
def index():
    """
    asks for the form page using a GET request.
    The form page will have a web form with input fields and a Submit button.
    When a user fills in the web form and clicks the Submit button,
    a POST request gets sent to the index() view function (the '/' route)
    The request is then being handled and validated

    returns a call to the render_template() function,
    which indicates to Flask that the route should display an HTML template
    """

    hostname = socket.gethostname()
    app.logger.debug(f"Omer: hostname: {hostname}")

    if request.method == 'POST':
        # getting user input
        user_input = request.form['wp_input']

        if not user_input:
            print(f"got no title")
            # the message can be pulled in the HTML using get_flashed_messages()
            flash("location field cannot be empty!")
        else:
            try:
                ret_list = wf_helper.get_weather_forecast(user_input)
            except Exception as e:
                print(f"Caught error: {e}")
                flash("There was an error processing the request")
            else:
                return render_template('result.html', html_loc = ret_list[0], html_dates_lst = ret_list[1],
                                       html_min_lst = ret_list[2], html_max_lst = ret_list[3])
    return render_template('form.html',hostname=hostname)


if __name__ != '__main__':
    # if we are not running directly, we set the loggers
    gunicorn_logger = logging.getLogger('gunicorn.error')
    # retrieves the Gunicorn server's logger with the name 'gunicorn.error' as 'gunicorn_logger'
    #   This logger is typically used by Gunicorn to handle server-related errors and events.
    app.logger.handlers = gunicorn_logger.handlers
    # sets the Flask application's logger handlers to the same handlers used by the Gunicorn logger.
    #   any log messages generated by the Flask application will be sent to
    #   the same log destinations as the Gunicorn server's logs
    app.logger.setLevel(gunicorn_logger.level)
    # sets the Flask application's logger level to the same level as the Gunicorn logger


if __name__ == '__main__':
    #pass
    # 0.0.0.0 - Running on all addresses
    # for testing with flask:
    app.run(host='0.0.0.0', port=5000, debug=True) # with debug
    
    # to run with gunicorn with listening to all IPs, use:
    #   gunicorn --bind 0.0.0.0:5000 wf:app
    # gunicorn --bind 0.0.0.0:5000 --log-level=DEBUG wf:app
